查询语句的那一套流程，更新语句也是同样会走一遍。步骤如下：
1. 连接器连接数据库
2. 清空这个表的缓存
3. 分析器分析是更新
4. 优化器决定使用 id 索引
5. 执行器负责执行，然后更新

更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：**redo log（重做日志）和 binlog（归档日志）**。如果接触 MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log 和 binlog 在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。

## 重要的日志模块：redo log

举例孔乙己中的酒店老板记账，先用黑板记账，黑板记不下记到账本上。如果太忙就记黑板，空了往账本誊抄。如果忙的时候黑板记不下，先把黑板誊抄一点到账本再继续工作。

在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。

具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。

另外 InnoDB 的 redo log 是固定大小的（相当于黑板大小是固定的），比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写。

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢
失，这个能力称为 **crash-safe**。

> 这个模块只有 InnoDB 引擎才有。

## 重要的日志模块：binlog


