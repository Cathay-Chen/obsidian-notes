

## 概述

逻辑架构图:

![[Pasted image 20230112223415.png]]


MySQL 可以分为 Server 层和存储引擎层两部分。

- Server 层：包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
- 存储引擎层：负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。

> 不同的存储引擎共用一个Server 层，也就是从连接器到执行器的部分。

## 连接器

连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：

```bash
mysql -h$ip -P$port -u$user -p
```

一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。

### show processlist  查看客户端连接信息

可以使用 `show processlist`  命令查看所有的连接一些信息。

![[Pasted image 20230112224425.png]]

### wait_timeout 设置闲置断开时间

可以使用 `wait_timeout` 参数控制连接器闲置自动断开时间。默认是 8 小时。修改方法如下：

```bash
mysql> set global wait_timeout = 280000;
Query OK, 0 rows affected (0.00 sec)

mysql>
```

如果想让MySQL无论从哪种客户端都能让 `wait_timeout` 一致，那就要同时设置 `global wait_timeout` 和 `global interactive_timeout`了。例如:

```bash
mysql> set global wait_timeout = 280000;
Query OK, 0 rows affected (0.00 sec)

mysql> set global interactive_timeout = 280000;
Query OK, 0 rows affected (0.00 sec)

mysql>
```

>也可以通过 my.conf 设置

### 长连接内存占用问题

大量使用长连接（长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接）可能会有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。

怎么解决这个问题呢？你可以考虑以下两种方案。

1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
2. 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行`mysql_reset_connection` 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

## 查询缓存

MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执
行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的
语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个
value 就会被直接返回给客户端。

**但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。**

查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。
因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大
的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才
会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。

好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 `query_cache_type` 设置
成 `DEMAND`，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓
存的语句，可以用 `SQL_CACHE` 显式指定，像下面这个语句一样：

```bash
mysql> select SQL_CACHE * from T where ID=10；
```

> 需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻
底没有这个功能了。


## 分析器

如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，
因此需要对 SQL 语句做解析。

分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，
MySQL 需要识别出里面的字符串分别是什么，代表什么。

MySQL 从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符
串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。

做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法
规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

如果你的语句不对，就会收到 “You have an error in your SQL syntax” 的错误提醒，比
如下面这个语句 select 少打了开头的字母“s”。

```bash
mysql> elect * from t where ID=1;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that correspo
```

一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接 “use near” 的内
容。

## 优化器

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联
（join）的时候，决定各个表的连接顺序。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。

## 执行器

开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返
回没有权限的错误。

如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这
个引擎提供的接口。

